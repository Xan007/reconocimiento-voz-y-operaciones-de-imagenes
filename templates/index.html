{% extends "base.html" %}

{% block content %}
<script src="{{ url_for('static', filename='js/audio-config.js') }}"></script>

<div class="page-header">
    <h1><i class="fas fa-wave-square"></i> Reconocimiento en Tiempo Real</h1>
    <p class="subtitle">Graba un comando y obtén el reconocimiento instantáneo</p>
</div>

    <div class="recognition-container">
        <div class="control-panel">
            <div class="recording-controls" style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                <button id="recordButton" class="btn btn-primary btn-lg" style="flex: 1;">
                    <i class="fas fa-circle"></i> Grabar
                </button>
                <button id="toggleFileUpload" class="btn btn-secondary btn-lg" style="flex: 1; padding: 0.8rem;">
                    <i class="fas fa-upload"></i> Cargar
                </button>
            </div>

            <div class="recording-time" id="recordingTime" style="display: none; margin-bottom: 1rem;">
                Grabando: <span id="timeCounter">0.0</span>s / 1.0s
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div id="fileUploadPanel" style="display: none; margin-bottom: 1rem; padding: 0.8rem; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;">
                <input type="file" id="audioFileInput" accept=".wav,.mp3,.ogg,.webm" style="margin-bottom: 0.5rem; font-size: 0.9rem;" />
                <button id="uploadButton" class="btn btn-secondary" style="font-size: 0.9rem; padding: 0.5rem 1rem;">
                    <i class="fas fa-check"></i> Procesar
                </button>
            </div>

            <div class="status-indicator" id="statusIndicator" style="margin-bottom: 1rem;">
                <span class="status-dot"></span>
                <span class="status-text">Listo</span>
            </div>

            <div class="audio-playback" id="audioPlayback" style="display: none; margin-bottom: 1rem;">
                <h4 style="margin-bottom: 0.5rem; font-size: 0.95rem;">Reproductor</h4>
                <audio id="audioPlayer" controls style="width: 100%;">
                    Tu navegador no soporta el elemento de audio
                </audio>
            </div>

            <div class="recognition-result" id="recognitionResult" style="display: none; margin-bottom: 1rem;">
                <div class="result-badge">
                    <span class="result-label">Comando:</span>
                    <span class="result-command" id="resultCommand">-</span>
                </div>
                <div class="result-confidence">
                    <span class="confidence-label">Distancia:</span>
                    <span class="confidence-value" id="confidenceValue">-</span>
                </div>
            </div>

            <div style="display: none;" id="modelsTable"></div>

        </div>    <div class="plots-container">
        <div class="plot-section" style="margin-bottom: 1rem;">
            <button id="toggleDetails" class="btn btn-secondary btn-sm" style="padding: 0.5rem 1rem; font-size: 0.9rem; margin-bottom: 0.5rem;">
                <i class="fas fa-chevron-down"></i> Ver Detalles de Análisis
            </button>
            <div id="detailsPanel" style="display: none;">
                <div class="plot-section">
                    <h3><i class="fas fa-wave-sine"></i> Forma de Onda</h3>
                    <div id="waveformPlot" class="plot"></div>
                </div>

                <div class="plot-section">
                    <h3><i class="fas fa-spectrum"></i> Espectro de Frecuencia</h3>
                    <div id="spectrumPlot" class="plot"></div>
                </div>

                <div class="plot-section">
                    <h3><i class="fas fa-table"></i> Comparación de Distancias</h3>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 0.5rem; border-bottom: 2px solid #0066cc;">Modelo</th>
                                <th style="text-align: left; padding: 0.5rem; border-bottom: 2px solid #0066cc;">Distancia</th>
                            </tr>
                        </thead>
                        <tbody id="detailsTableBody">
                        </tbody>
                    </table>
                </div>

                <div id="energyComparisonContainer" class="energy-comparison"></div>
            </div>
        </div>

{% endblock %}

{% block scripts %}
<script>
    const MAX_RECORDING_TIME = 1.0; // 1 segundo máximo
    
    const recordButton = document.getElementById('recordButton');
    const statusIndicator = document.getElementById('statusIndicator');
    const recordingTime = document.getElementById('recordingTime');
    const timeCounter = document.getElementById('timeCounter');
    const audioPlayback = document.getElementById('audioPlayback');
    const audioPlayer = document.getElementById('audioPlayer');
    const audioFileInput = document.getElementById('audioFileInput');
    const uploadButton = document.getElementById('uploadButton');
    
    let audioContext;
    let processor;
    let scriptNode;
    let lastRecordingBlob = null;
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let recordingStartTime;
    let timerInterval;

    // Clase para codificar WAV
    class WavEncoder {
        static encode(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            function writeString(offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, samples.length * 2, true);

            let offset = 44;
            for (let i = 0; i < samples.length; i++) {
                let s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                offset += 2;
            }

            return buffer;
        }
    }

    // Inicializar grabadora de audio
    async function initRecorder() {
        try {
            const options = await getAudioOptions();
            const stream = await navigator.mediaDevices.getUserMedia(options);
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            
            // Usar ScriptProcessorNode para capturar audio raw
            scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
            source.connect(scriptNode);
            scriptNode.connect(audioContext.destination);
            
            if (recordButton) {
                recordButton.disabled = false;
            }
            console.log('✅ Grabadora de audio inicializada');
        } catch (error) {
            console.error('Error al acceder al micrófono:', error);
            if (recordButton) {
                recordButton.disabled = true;
            }
            alert('No se pudo acceder al micrófono. Verifica los permisos.');
        }
    }

    // Alternar grabación
    if (recordButton) {
        recordButton.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });
    } else {
        console.error('recordButton no encontrado');
    }

    function startRecording() {
        audioChunks = [];
        isRecording = true;
        recordButton.innerHTML = '<i class="fas fa-stop"></i> Detener';
        recordButton.classList.add('recording');
        recordingTime.style.display = 'block';
        
        recordingStartTime = Date.now();
        timerInterval = setInterval(updateTimer, 100);
        
        updateStatus('Grabando...', 'recording');
        
        // Capturar audio desde ScriptProcessorNode
        scriptNode.onaudioprocess = (event) => {
            if (isRecording) {
                const inputData = event.inputBuffer.getChannelData(0);
                audioChunks.push(new Float32Array(inputData));
            }
        };
    }

    function stopRecording() {
        isRecording = false;
        recordButton.innerHTML = '<i class="fas fa-circle"></i> Grabar';
        recordButton.classList.remove('recording');
        recordingTime.style.display = 'none';
        clearInterval(timerInterval);
        
        updateStatus('Procesando...', 'processing');
        
        // Detener el procesamiento de audio
        scriptNode.onaudioprocess = null;
        
        // Procesar la grabación
        processRecording();
    }

    function updateTimer() {
        const elapsed = (Date.now() - recordingStartTime) / 1000;
        timeCounter.textContent = elapsed.toFixed(1);
        
        // Actualizar la barra de progreso (0-100%)
        const progressPercent = Math.min(100, (elapsed / MAX_RECORDING_TIME) * 100);
        document.getElementById('progressFill').style.width = progressPercent + '%';
        
        // Auto-detener después de 1 segundo EXACTO
        if (elapsed >= MAX_RECORDING_TIME) {
            stopRecording();
        }
    }

    async function processRecording() {
        try {
            if (audioChunks.length === 0) {
                alert('No se capturó audio. Intenta de nuevo.');
                updateStatus('Error', 'error');
                return;
            }

            // Concatenar todos los chunks
            const totalLength = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const audioData = new Float32Array(totalLength);
            let offset = 0;
            for (let chunk of audioChunks) {
                audioData.set(chunk, offset);
                offset += chunk.length;
            }

            // Codificar a WAV
            const sampleRate = audioContext.sampleRate;
            const wavBuffer = WavEncoder.encode(audioData, sampleRate);
            const blob = new Blob([wavBuffer], { type: 'audio/wav' });
            
            // Guardar el blob para reproducción
            lastRecordingBlob = blob;
            
            // Mostrar reproductor de audio
            const audioUrl = URL.createObjectURL(blob);
            audioPlayer.src = audioUrl;
            audioPlayback.style.display = 'block';

            // Enviar al servidor
            const formData = new FormData();
            formData.append('audio', blob, 'recording.wav');

            updateStatus('Enviando...', 'processing');

            const response = await fetch('/api/recognize', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                displayResults(result);
                updateStatus('Listo', 'ready');
            } else {
                alert('Error en el reconocimiento: ' + result.error);
                updateStatus('Error', 'error');
                console.error('Error:', result);
            }
        } catch (error) {
            console.error('Error procesando grabación:', error);
            alert('Error al procesar la grabación: ' + error.message);
            updateStatus('Error', 'error');
        }
    }

    function displayResults(result) {
        // Mostrar comando reconocido
        const recognitionResult = document.getElementById('recognitionResult');
        const resultCommand = document.getElementById('resultCommand');
        const confidenceValue = document.getElementById('confidenceValue');
        
        if (result.recognized_command) {
            resultCommand.textContent = result.recognized_command.toUpperCase();
            recognitionResult.classList.add('success');
            confidenceValue.textContent = result.differences[result.recognized_command].toFixed(6);
        } else {
            resultCommand.textContent = 'No reconocido';
            recognitionResult.classList.remove('success');
            confidenceValue.textContent = '-';
        }
        
        // Mostrar el panel de detalles
        document.getElementById('recognitionResult').style.display = 'block';
        document.getElementById('toggleDetails').click();

        // Graficar datos
        const plotData = result.plot_data;
        
        // Forma de onda - OCUPAR TODO EL ANCHO DEL CONTENEDOR
        Plotly.newPlot('waveformPlot', [{
            x: plotData.waveform.x,
            y: plotData.waveform.y,
            type: 'scatter',
            mode: 'lines',
            name: 'Forma de Onda',
            line: { color: '#0066cc', width: 1 }
        }], {
            title: 'Forma de Onda',
            xaxis: { title: 'Tiempo (s)' },
            yaxis: { title: 'Amplitud' },
            margin: { l: 50, r: 20, t: 40, b: 40 },
            responsive: true,
            autosize: true,
            plot_bgcolor: '#f8f9fa',
            paper_bgcolor: 'white'
        }, { responsive: true });

        setTimeout(() => { 
            Plotly.Plots.resize('waveformPlot');
            requestAnimationFrame(() => Plotly.Plots.resize('waveformPlot'));
        }, 150);

        // Espectro - OCUPAR TODO EL ANCHO HORIZONTAL
        const spectrumMagnitude = plotData.spectrum.y.map(val => {
            // Convertir de dB a magnitud lineal: mag = 10^(dB/20)
            return Math.pow(10, val / 20);
        });
        
        Plotly.newPlot('spectrumPlot', [{
            x: plotData.spectrum.x,
            y: spectrumMagnitude,
            type: 'scatter',
            mode: 'lines',
            name: 'Espectro',
            line: { color: '#ff6600', width: 1.5 },
            fill: 'tozeroy',
            fillcolor: 'rgba(255, 102, 0, 0.2)'
        }], {
            title: 'Espectro de Frecuencia Completo (0 - 22050 Hz)',
            xaxis: { title: 'Frecuencia (Hz)', zeroline: false },
            yaxis: { title: 'Magnitud Lineal', zeroline: true },
            margin: { l: 50, r: 20, t: 40, b: 40 },
            responsive: true,
            autosize: true,
            plot_bgcolor: '#f8f9fa',
            paper_bgcolor: 'white'
        }, { responsive: true });

        setTimeout(() => { 
            Plotly.Plots.resize('spectrumPlot');
            requestAnimationFrame(() => Plotly.Plots.resize('spectrumPlot'));
        }, 150);

        // Comparaciones de energía - SOLO 2 GRÁFICAS, UNA ENCIMA DE LA OTRA
        const energyComparisonDiv = document.getElementById('energyComparisonContainer');
        energyComparisonDiv.innerHTML = '';

        const modelsList = Object.keys(result.plot_data.models_comparison);
        
        for (const [modelName, data] of Object.entries(result.plot_data.models_comparison)) {
            const card = document.createElement('div');
            card.className = 'plot-section';

            const heading = document.createElement('h3');
            heading.innerHTML = `<i class="fas fa-chart-bar"></i> Modelo ${modelName.toUpperCase()} vs Tu Grabación`;
            card.appendChild(heading);

            const plotId = `energyPlot_${modelName}`;
            const plotDiv = document.createElement('div');
            plotDiv.id = plotId;
            plotDiv.className = 'plot';
            plotDiv.style.cssText = 'height: 300px;';
            card.appendChild(plotDiv);

            energyComparisonDiv.appendChild(card);

            const nBands = data.model_energies.length;
            const bands = Array.from({length: nBands}, (_, i) => `B${i+1}`);

            // Gráfica de BARRAS LADO A LADO para comparar claramente
            Plotly.newPlot(plotId, [
                {
                    x: bands,
                    y: data.model_energies,
                    name: `Modelo ${modelName.toUpperCase()}`,
                    type: 'bar',
                    marker: { color: '#0066cc' },
                    customdata: data.input_energies,
                    hovertemplate: '<b>Banda: %{x}</b><br>Modelo: %{y:.6f}<br>Grabación: %{customdata:.6f}<extra></extra>'
                },
                {
                    x: bands,
                    y: data.input_energies,
                    name: 'Tu Grabación',
                    type: 'bar',
                    marker: { color: '#00cc66' },
                    customdata: data.model_energies,
                    hovertemplate: '<b>Banda: %{x}</b><br>Grabación: %{y:.6f}<br>Modelo: %{customdata:.6f}<extra></extra>'
                }
            ], {
                title: `Modelo ${modelName.toUpperCase()} vs Tu Grabación`,
                barmode: 'group',
                xaxis: { title: 'Banda', automargin: true },
                yaxis: { title: 'Energía Relativa', automargin: true },
                margin: { l: 50, r: 20, t: 40, b: 40 },
                responsive: true,
                autosize: true,
                plot_bgcolor: '#f8f9fa',
                paper_bgcolor: 'white',
                hoverlabel: { namelength: -1 }
            }, { responsive: true });

            // Forzar recálculo del tamaño después de dibujar (múltiples veces para garantizar)
            setTimeout(() => {
                Plotly.Plots.resize(plotId);
            }, 150);
            
            setTimeout(() => {
                Plotly.Plots.resize(plotId);
                requestAnimationFrame(() => Plotly.Plots.resize(plotId));
            }, 300);
        }

        // Tabla de diferencias - dentro de detalles
        const detailsTableBody = document.getElementById('detailsTableBody');
        detailsTableBody.innerHTML = '';
        
        for (const [modelName, diff] of Object.entries(result.differences)) {
            const row = `<tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 0.5rem; text-align: left;">${modelName.toUpperCase()}</td>
                <td style="padding: 0.5rem; text-align: left;">${diff.toFixed(6)}</td>
            </tr>`;
            detailsTableBody.insertAdjacentHTML('beforeend', row);
        }
    }

    function updateStatus(text, state) {
        const indicator = document.querySelector('.status-indicator .status-text');
        const dot = document.querySelector('.status-dot');
        indicator.textContent = text;
        dot.className = `status-dot status-${state}`;
    }

    // Inicializar al cargar
    window.addEventListener('load', initRecorder);
    
    // Toggle para cargar archivo
    document.getElementById('toggleFileUpload').addEventListener('click', () => {
        const panel = document.getElementById('fileUploadPanel');
        const btn = document.getElementById('toggleFileUpload');
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
            btn.innerHTML = '<i class="fas fa-chevron-up"></i> Ocultar';
        } else {
            panel.style.display = 'none';
            btn.innerHTML = '<i class="fas fa-chevron-down"></i> Cargar Audio';
        }
    });
    
    // Toggle para detalles de análisis
    document.getElementById('toggleDetails').addEventListener('click', () => {
        const panel = document.getElementById('detailsPanel');
        const btn = document.getElementById('toggleDetails');
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
            btn.innerHTML = '<i class="fas fa-chevron-up"></i> Ocultar Detalles';
            
            // Redimensionar todos los plots después de que se muestre el panel
            setTimeout(() => {
                Plotly.Plots.resize('waveformPlot');
                Plotly.Plots.resize('spectrumPlot');
                document.querySelectorAll('[id^="energyPlot_"]').forEach(el => {
                    Plotly.Plots.resize(el.id);
                });
            }, 200);
        } else {
            panel.style.display = 'none';
            btn.innerHTML = '<i class="fas fa-chevron-down"></i> Ver Detalles de Análisis';
        }
    });
    
    // Botón cargar archivo
    uploadButton.addEventListener('click', async () => {
        const file = audioFileInput.files[0];
        if (!file) {
            alert('Por favor selecciona un archivo de audio');
            return;
        }
        
        try {
            updateStatus('Procesando archivo...', 'processing');
            
            const formData = new FormData();
            formData.append('audio', file);
            
            const response = await fetch('/api/recognize', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Mostrar el archivo en el reproductor
                const audioUrl = URL.createObjectURL(file);
                audioPlayer.src = audioUrl;
                audioPlayback.style.display = 'block';
                lastRecordingBlob = file;
                
                displayResults(result);
                updateStatus('Listo', 'ready');
            } else {
                alert('Error en el reconocimiento: ' + result.error);
                updateStatus('Error', 'error');
                console.error('Error:', result);
            }
        } catch (error) {
            console.error('Error procesando archivo:', error);
            alert('Error al procesar el archivo: ' + error.message);
            updateStatus('Error', 'error');
        }
    });
</script>
{% endblock %}
